#summary Information about RUR-ITS

===Launching RUR-ITS===

RUR-ITS can be started by executing rur_start.py

By default, RUR-ITS will start by launching a pretest, which will need to be completed before entering the system, and using the system will be followed by a post-test.  Problem selection will be a fixed order as it is set in the problems file (usually in increasing order of difficulty).  RUR-ITS accepts a few command-line arguments to change the default behavior.  These arguments are not positional and are not flags, so they should be given as is, in any order.

skip - skip the pretest and post-test and enter the system immediately<br>
aps - use the adaptive problem selection algorithm to select the best problem every time<br>
fps - rank the problems by the adaptive problem selection algorithm after completing the pretest, and thereafter go through the problems in a fixed order from most to least helpful as determined by the algorithm

===Adding and modifying content===

The default instructions file is lessons/en/instr.htm

The concept outline for the test questions and RUR-PLE problems is given on the first page of rurprogs.pdf, available in Downloads.

The pretest and post-test questions are defined in rur_py/questions.py

The lists defining which questions are in each test are defined at the bottom.  Each question is a Question object, with the following constructor arguments:<br>
instr - The text of the question.<br>
code - The code associated with the question.<br>
choices - A list of answer choices, each as a string, for multiple-choice questions.  For a short-answer question, this should be an empty list.<br>
correct - The correct answer.  For multiple-choice questions, this should be a 0-indexed index into the choices list.  For short-answer questions this should be a string containing the text of the correct answer.  Note that whitespace is stripped from the ends of answers and the end of each line (of both the correct answer and the user's answer) before checking for correctness.<br>
concepts - A list of outline identifiers of the concepts for the question, ex: ["IA1","IB2a"].

The RUR-PLE problems are defined in rur_py/problems.py

The lists defining which problems are program tracing problems and which are program writing problems are defined at the bottom (note that a problem can be in both lists).  Each problem is a function that returns a tuple containing (1) the environment and (2) the code.  The environment is a dictionary, and the environments are generated by functions in rur_py/environment.py.  The code is a string containing the implementation code for the problem.  Each function defining a problem has two class attributes attached to it:<br>
concepts - A list of outline identifiers of the concepts for the question, ex: ["IA1","IB2a"].<br>
difficulty - Difficulty level of the problem, on a scale from 1 to 10.

===Future work===

Currently, the RUR-PLE problems given by RUR-ITS are all program tracing and prediction problems where the user is given an environment and code, and is asked to predict the behavior of the program.  The following enhancements are planned to add support for program writing problems.

The system will accept "write" as a command-line argument to use program writing problems instead of prediction problems.

The problem definitions in rur_py/problems.py will work as follows.  The code returned by the function will not be loaded into RUR-ITS and should be the code for a correct implementation of the problem's solution.  The code may be used to check the user's solution.  The function should have one more class attribute attached to it:<br>
instructions - filename of a HTML file in lessons/en/intro giving the instructions for the problem, describing what the program the user is being asked to write should do.

===Known Bugs===

The only known bug affects the visualization when a user's prediction was incorrect.  While executing the visual diff of the program's correct behavior and the user's prediction, there is a glitch when executing the last correct robot command predicted before an incorrect prediction action.

The blue robot (with the blue trace line) representing the user's prediction will execute the last correct command correctly.  The gray robot (with the green trace line) representing the correct behavior will not, however, execute the last correct action immediately thereafter as it should.  Once the blue robot has finished executing the incorrect actions, the gray robot will finally execute the last correct action that should have happened before the incorrect actions.  Basically once the prediction syncs up with the correct behavior, the gray robot will catch up to where it should have been.

I believe this behavior is caused by the wx.Yield() statements sprinkled throughout the code (in rur_py/cpu.py) for executing the visualization, and is some sort of threading/locking-type problem.  I don't understand how this works well enough to fix it.